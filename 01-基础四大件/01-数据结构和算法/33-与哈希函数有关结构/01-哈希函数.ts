/**1.哈希函数特性**/

//输入无限
//输出有限
//相同的输入一定有相同的输出
//不同的输入可能有相同的输出（哈希碰撞）
//哈希函数具有离散型 （最重要的特性）

/**2 哈希表的设计**/

//哈希表有个初始的桶空间，每个桶里面是一个链表
//根据哈希函数的特性，当一个新的值来临的时候会均匀的分布到每个桶中，所以每个桶应该是均匀生长
//哈希表对桶有扩容行为，因为通过哈希函数找到桶的代价是O(1),所以必须满足桶中的链表数量是有规模的，否则链表也会有复杂度
//如果桶（假设桶17，哈希函数模17）中的链表满了，就把桶的数量扩容一倍（桶34个），重新对每一个数做哈希函数（模34），这样一倍时候即将满的桶扩容到二倍后，桶中链的数量会减半
//扩容的总代价是O(N)（1+2+4+8+N/4+N/2收敛于N）,但是均摊下来扩容的代价是O(1)

/** 3.布隆过滤器**/

//查询一个数据在一个很庞大的数据中存不存在（比如说查找URL是否在黑名单系统）
//如果允许一定的失误率（假阳性，数据不在数据库中，但是判断为存在数据）
//确定一个M空间，确定k个哈希函数，通过哈希函数的离散型对每一个数通过k个哈希函数在M空间上（模M）后的位置描黑
//当查询一个数时候，如果k个哈希函数返回在M空间中的位置全是黑的，则存在
//布隆过滤器最重要的就是k的数量和M空间的设计，如果知道允许失误率，便可以带入公式求解

/** 4.一致性哈希**/

//解决数据存储端服务器分布式存储的一种方案
//--->传统的服务器结构：前端（Nginx），逻辑端和数据存储端
//--->当一个请求从前端到逻辑端处理有，假设{key:**,value:**},则以key作为值通过哈希函数处理后模上数据服务器的数量，来确定到底到放到哪台服务器上
//--->哈希函数非常离散，所以存数据的时候可以达到负载均衡
//--->但是实际的业务中，在查询的时候不同的key可能访问频率不同，会导致读的时候负载不均衡，所以存的时候要保证高频，中频，低频的词在每个数据服务器都要有一定的数量
//--->传统的负载均衡在增加删除机器的时候是全量更新，比如原来3台机子数据量1亿，现在数据量到了10亿，要增加3机子，必须把原来3台机子中所有的数据重新%6，放到6台机子上
//----》一致性哈希用来解决数据全量更新的问题，可以做到数据迁移的代价很低，同时做到负载均衡
//----》把hash函数的返回值想象成一个环，然后用数据服务器的唯一标识（MAC地址或其他）做hash，假设会均匀的分散到环上，假设三台机子算出来的hashcode是m1:3 m2:100亿 m3:2000亿
//----》把[3,100亿，2000亿]路由表数组分配到每一个逻辑服务器上，当存数据的时候通过hash函数（不取模）得到一个hashcode，然后顺时针找到离它最近比它大的值，便是它要存入的数据服务器
//----》当新增一台机子时，只需要把顺时针离它最近机子部分数据交给新的机子就行
//----》当移除一台机子时，只需要把该机子的数据交给顺时针离它最近机子就行
//----》利用虚拟节点技术解决点很少的时候hash没办法均分问题和一开始均分加减机子后又不均的问题
//----》虚拟节点技术：不用机器的唯一标识去抢环，人为分配去抢（假设每个机器有1000个字符串是一个路由表，3台机器用3000个字符串去抢，分布均匀，每个部分占1/3）
