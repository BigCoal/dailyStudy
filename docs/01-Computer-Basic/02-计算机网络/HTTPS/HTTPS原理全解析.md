# HTTPS原理全解析

前言
--

超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。

HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

HTTPS 是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。

SSL 是 “Secure Sockets Layer” 的缩写，中文叫做 “安全套接层”，其出现就是为了解决 HTTP 传输不安全的问题；到了 1999 年，SSL 被标准化，标准化之后的名称改为 TLS（是“Transport Layer Security” 的缩写），中文叫做“传输层安全协议”，所以这两者其实就是同一种协议，只不过是在不同阶段的不同称呼。

这篇文章，将形象的讲解 HTTPS 的加密原理，理解为什么 HTTPS 会如此的安全。

传输方式
----

### 明文传输

明文传输就是传输给服务器的内容不经过任何处理，如 "做我女朋友吧"，黑客能直接获取到我们传输的明文内容，如果有涉及到重要的信息，是非常不安全的。

![](./static/f7169d7ee51549c69b84a318e8345186~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=516&h=408&s=18350&e=png&b=fdfdfd)

### 对称加密

对称加密，又被成为私钥加密，即信息的发送方和接收方使用同一个秘钥去加密和解密信息，它采用了对称密码编码技术。常见的对称加密算法如：AES。

对称加密算法密钥较短，破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，且对计算机性能要求也没有那么高。

#### 对称加密过程

客户端向服务端发起请求，服务端收到请求后向客户端发送私钥。客户端存储私钥，后续向服务端发送的信息都需要通过私钥加密，然后服务端收到加密后的信息用私钥解密。服务端也可以通过私钥加密信息发送给客户端，客户端同样再利用私钥解密。

![](./static/e91f1d6bbccc46e0af13d1d09ee338ca~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=962&h=531&s=45277&e=png&b=fdfdfd)

#### 对称加密优点

对称加密的主要优点是加密速度快。

#### 对称加密安全性

由于访问的用户数量可能非常庞大，服务器如果给每个用户下发的私钥是唯一的，那意味着服务器也要相应存储大量的私钥，这将消耗大量的存储，所以对称加密的私钥是唯一的，由服务端制定下发给客户端。即每个用户都拥有相同的私钥，也就意味着黑客也可以获取到私钥，利用私钥就能破解客户端向服务端以及服务端向客户端传输的信息。

![](./static/aab5ccd5449a4fd38123e4ffd385a173~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=984&h=540&s=55201&e=png&b=fdfdfd)

所以对称加密也是不安全的。

### 非对称加密

与对称加密算法不同，非对称加密算法需要使用两个秘钥：公开秘钥、私有秘钥，即公钥和私钥，而且公钥和私钥是成对出现的。一个公钥对应一个私钥，一个私钥对应一个公钥。常见的非对称加密算法如：RSA。

公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

#### 非对称加密过程

1.  客户端向服务端发起请求, 获取公钥。
2.  服务端收到请求，返回公钥给客户端。
3.  客户端收到服务端返回的公钥，储存起来，用公钥将信息加密发送给服务端。
4.  服务端收到信息，用私钥进行解密。然后，由于客户端只有公钥，服务端向客户端发送的信息只能用私钥加密。
5.  客户端收到服务端信息，用公钥解密，得到解密后的信息。再继续用公钥加密信息发送给服务端。

![](./static/6fea16afb684474999572bf8af8ab574~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=976&h=523&s=47560&e=png&b=fefefe)

#### 非对称加密优点

非对称加密的主要优点是可以安全传输公钥。

#### 非对称加密安全性

非对称加密过程看起来是很完美的，私钥一直在服务端，黑客没办法获取私钥，也就没办法破解客户端通过公钥加密的信息。

但是在第一步获取服务器公钥过程中，可能被黑客拦截，黑客也有自己的公钥和私钥，他把自己的公钥给到客户端，然后冒充客户端向服务器请求获取公钥，服务器收到请求后就下发给 "客户端" 公钥，这样黑客就拿到了服务器公钥。后面传输信息过程中，客户端用黑客的公钥加密，然后发送给了服务器（黑客），黑客用自己的私钥解密得到信息，服务端用私钥加密响应信息给客户端（黑客），黑客用服务器的公钥进行解密。这样黑客能同时破解客户端和服务端发送的信息了。

在第 4 步中，服务端将私钥加密过的信息发送给客户端时，黑客也是有公钥的（黑客也是用户），黑客在这里可以截获加密信息然后用它手中的公钥进行解密，这样，黑客还是破解了服务端向客户端发送的信息。

![](./static/a9dd1b04bfb84c2bb2031c09408b98d6~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=832&h=531&s=57048&e=png&b=fdfdfd)

所以非对称加密同样不安全。

### 对称加密和非对称加密总结

对称加密的问题是密钥只有一个，所有人都共享同一个密钥，如果客户端都有自己的密钥，而且不被黑客截取到就能安全地传输了。

非对称加密客户端向服务端发送信息的时候是安全的，只是服务端向客户端发送信息是不安全的。黑客作为中间人会冒 "客户端" 和 "服务端"，拿到客户端向服务端请求信息以及服务端向客户端响应的信息。

由此可见，两种加密方式各有优点，那我们能不能将两种加密方式结合起来呢？

### 混合加密

混合加密就是对称加密和非对称加密的结合。

#### 混合加密过程

混合加密就是我们先用非对称加密在客户端和服务端生成一个密钥，然后我们再用对称加密，使用非对称加密得来的密钥进行加密传输。HTTPS 正是用的这种加密方式。

#### 混合加密过程

1.  客户端向服务端发起请求, 获取公钥。
    
2.  服务端收到请求，返回公钥给客户端。
    
3.  客户端生成随机数 num1，用公钥加密，发送给服务端。
    
4.  服务器收到加密后的 num1，利用自己的私钥解密得到 num1。
    
5.  服务端和客户端商议 OK，可以将 num1 作为密钥进行加密。
    

到这一步为止，整个加密过程和非对称加密一样。

6.  客户端和服务端将 num1 作为对称加密的密钥进行加密，开始以对称加密的方式开始相互传输数据。

整个过程，前期以非对称加密在客户端和服务端得到了随机数 num1，黑客没有私钥没法解密得到 num1，后面两端以 num1 为密钥进行对称加密传输，由于黑客没法得到 num1，所以整个传输过程是安全的。

#### 混合加密安全性

上面我们得出了混合加密是安全的结论，但是黑客也是神通广大，看似这么严谨的传输，也还是被它破解了。那么问题出在哪里了呢？

问题的原因还是和非对称加密一样出在了第一步，客户端向服务端发起请求, 获取公钥的过程中。聪明的黑客在这一过程中进行了拦截，黑客自己也有自己的公钥和私钥，这里为了区分服务端的公钥和私钥，我们用 PK2,SK2 和 PK、SK 代表黑客和服务端的公钥、私钥。黑客拦截了客户端的请求然后将自己的公钥 PK2 返回给了客户端，这样客户端拿到的就是黑客的公钥了。黑客自己再冒充客户端向服务端发起请求，服务端将公钥 PK 返回给了黑客，这样黑客得到了 PK。客户端生成随机数 num1，然后用 PK2 加密传输给服务端，这过程中黑客仍然截获了信息然后用自己的私钥 SK2 进行解密，这样就拿到了客户端传输的信息。这里黑客用 PK 给信息加密，发送给服务端，服务端用 SK 解密得到信息，继续用 SK 加密将信息返回给客户端，黑客截获后用 PK 解密，这样黑客即能获取客户端也能获取服务端返回的数据了，而这一切客户端和服务端感知不到。黑客以 "中间商" 的身份在客户端和服务端之间做消息转发，但是这个 "中间商" 并不只是赚差价，而是窃取传递的信息甚至篡改。

这样一分析，混合加密也存在很大的安全风险，如何解决黑客 "中间人" 的问题呢？

**关键在于第二步，如何保证服务端发送给客户端的公钥是正确的！**

CA
--

CA（Certificate Authority）是采用公开密钥基础技术，专门提供网络身份认证服务，负责签发和管理数字证书，且具有权威性和公正性的第三方信任机构。CA 的作用类似于我们现实生活中颁发证件的机构，如身份证办理机构等。

混合加密的问题是黑客截获了客户端请求，给客户端下发了自己的公钥，如果我们能验证公钥是否是服务端发放的，那就能解决问题了。

CA 就是来帮我们做这一步的，只有经过 CA 权威机构认证的公钥才是好的公钥。

### 签名与验签

CA 机构用自己的私钥加密服务器公钥的过程叫做签名。

客户端用 CA 公钥解密 CA 私钥加密服务器公钥数据的过程叫做验签。

### 证书

CA 机构用自己的私钥加密服务器的公钥得到的数据就是我们所说的证书。

![](./static/a50b81cd87b74eb98be6e082b0ed7fe4~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=548&h=368&s=20554&e=png&b=fdfdfd)

CA 证书内一般会包含以下内容：

*   证书的颁发机构、版本。
*   访问地址的域名。
*   证书的使用者。
*   证书的公钥。
*   证书的有效时间。
*   证书的数字签名 Hash 值和签名 Hash 算法。

我们输入地址访问百度, 那如何确定我们访问的地址是百度，而不是别的网站或者伪造的网站？

服务端需要申请 SSL/TLS 证书来证明这个网站是百度，SSL 证书保存在源服务器为一个数据文件。要让 SSL 证书生效就需要向 CA 申请。这个证书表明了网站域名是属于谁的、日期等信息以外重要的是还包含了特定的公钥和私钥。

总的来说，服务器安装了 SSL 证书，客户端拿到证书然后用 CA 公钥解密，通过能否成功验签得到服务器公钥来确认服务端的身份。

![](./static/c79a5b85a2394bbfb21ecc5841f2fa94~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=474&h=657&s=27326&e=png&b=fafafa)

### CA 认证过程

CA 也有自己的公钥和私钥。公钥是直接放在操作系统里面的（客户端）。

1.  客户端向服务端发起请求, 获取公钥。
2.  服务端用 CA 私钥加密服务端公钥得到证书（生成证书这一步是 CA 做的，一般需要付费），然后发送给客户端。
3.  客户端拿到证书，浏览器就能根据自己的证书列表判断服务器的证书是否可信。这一步黑客没办法拿到 CA 公钥，所以无法破解得到服务端公钥。即使再次充当中间人拦截后给客户端发送自己的公钥，操作系统里 CA 公钥也没办法解密成功，浏览器就会出现警告，提示我们访问的地址不安全。

CA 认证失败说明证书不是服务器下发的，就有可能是黑客的。

![](./static/206c6f0cd4bb49368b786eca75710cae~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=487&h=354&s=30489&e=png&b=fefefe)

后续继续用服务端公钥进行对称加密信息进行传输。

有人会有疑问：如果 CA 的公钥被人掉包了或者窃取了怎么办？

CA 机构都是经过严格审核和认证的，很大的第三方独立机构，CA 机构的公钥会作为一个证书被直接放在操作系统中，只有具有极高权限的系统级或者管理员级别的才能修改证书。

这些证书可以通过命令 certmgr.msc 查询到。这些证书处理着计算机与加密信任的方方面面，

![](./static/c61bcf2a07544265a8dd26b58bca0eb7~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=621&h=451&s=56870&e=png&b=fbfafa)

### TLS 握手过程

在加密的第五步：“服务端和客户端商议 OK，可以将 num1 作为密钥进行加密。” 说的比较简单，这里是 TLS 握手过程，他发生在 TCP 三次握手之后。

1.  客户端给服务端发送信息包括：TLS 版本、多个加密算法以及第一个随机数。
2.  服务器收到后向客户端发起响应，在响应报文里面会携带服务端支持的 TLS 版本、加密算法和第二个随机数。
3.  服务器再向客户端发一个响应。出示自己的证书，这样浏览器就能根据自己的证书列表判断服务器的证书是否可信。
4.  服务器用 CA 私钥加密服务端公钥，然后发送给客户端。
5.  客户端用系统里的 CA 公钥解密得到服务器的公钥。
6.  客户端生成第 3 个随机数，用刚刚得到服务器的公钥进行加密发送给服务器。客户端这边 TLS 协商没有问题了，加密开始。
7.  服务器用自己的私钥解密得到第三个随机数，第三个随机数，没有直接传输，这样只有客户端和服务端知道第三个随机数。除非服务器私钥被泄露。

到这里 TLS 握手就成功了。

8.  最后，客户端和服务端分别用第一随机数、第二随机数和第三随机数计算得出会话密钥，各自得到的会话密钥是相同的。到这里，前面所有的都是非对称加密，为了得到这个会话密钥。
9.  后面客户端和服务端使用会话密钥作为私钥进行加密解密传输信息，为对称加密。

![](./static/1caa263e6cfa47ec853a88dfbc1b7086~tplv-k3u1fbpfcp-jj-mark-3024-0-0-0-q75.png#?w=830&h=762&s=77844&e=png&b=fdfdfd)

TLS 握手过程会比较复杂，这里我做了一个简单的总结：

1.  客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份。
2.  客户端传递三个随机数，之后通过随机数来生成一个密钥。
3.  互相确认密钥，然后握手结束。
4.  数据开始通讯，都使用同一个对话密钥来加解密。

会话后面使用对称加密是因为非对称加密消耗的资源非常大。而且也没有人知道会话密钥是什么，所以最后都是用对称加密。如果与其他服务器建立连接，也会生成另外的会话密钥，会话密钥只能使用在当前会话，更加提高了安全性。

总结
--

HTTPS 加密原理是：对称加密 + 非对称加密 + CA。

CA：认证进行签名得到证书下发给客户端，客户端根据操作系统内置的 CA 自己的公钥进行验证（验签），验证通过则说明访问的服务器是受信任的，得到服务器公钥。

非对称加密：得到客户端和服务端都有相同的密钥。

对称加密：利用非对称加密得到的密钥进行后续数据传输。

HTTPS 加密原理，自己查找资料整理了一周，希望大家点个赞吧！